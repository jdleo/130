{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 John Leonardo\
12 February 2018\
CSC 130\
\
Write-Up Questions\
\
1. I was able to design the algorithms for the two stack implementations, but occasionally there would be intricate, little methods that I would get stuck on. In this case, I found Java API docs very useful, and also some Stack Overflow answers to some bugs I was having.\
\
2. I compiled and ran the Java Reverse program, and reversed the .dat file, with BOTH stack implementations. Then, I took the .dat and converted it to .wav using Sox program. I did this for both implementations. Then, I listened to the .wav files, and they were clear sentences rather than gibberish.\
\
3. No, I did not use any libraries.\
\
4. For a .dat file with 1 million lines, it would resize 17 times. For a .dat file with 1 trillion lines, it would resize 37 times. I wrote a Python script to increase x by x * 2 until it reached a million, and a trillion, respectively, and counted the iterations.}